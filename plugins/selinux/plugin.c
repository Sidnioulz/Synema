/* Copyright 2009 (c) ENSI de Bourges
 * 		88 boulevard Lahitolle, 18020 Bourges Cedex, France
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
/**
 * \file selinux.c
 * \brief SELinux plugin
 * \author Aline BOUSQUET <aline.bousquet@ensi-bourges.fr>
 * \author Zaina AFOULKI <zaina.afoulki@ensi-bourges.fr>
 *
 * This file contains the source code for the SELinux plugin.
 */
#define _GNU_SOURCE
#include <librsvg/rsvg.h>
#include <librsvg/rsvg-cairo.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>

#include <dirent.h>
#include <errno.h>
#include <stddef.h>
#include <sys/stat.h>
#include <sys/types.h>

#include "constants.h"
#include "frame-common.h"
#include "frame-utilities.h"
#include "machine.h"
#include "plugin.h"
#include "time-period.h"
#include "selinux.h"
#include "menu_functions.h"

char *get_display_name (frame_t *f)
{
	return "SELinux";
}



int is_refreshing_needed (frame_t *f)
{
	char 		*file_name 		= g_strdup_printf ("selinux_%i.txt", f->display_period.type);
	char		*path 			= frame_get_absolute_reports_path (f, file_name, NULL);
	int 		refreshing_needed;
	struct stat 	file;
	stat(path, &file);
		if (stat(path, &file) != 0) {
		    fprintf(stderr, "Error stat failed with the following error: %m %s \n", path);
		    refreshing_needed=0;
		}

		else {
		   	if ( file.st_atime > file.st_mtime ){ 
				refreshing_needed=0;  
			}
			else {
				refreshing_needed=1;
			}
		}
	g_free (path);
	g_free (file_name);
	//return refreshing_needed; 
	return 1;
}



int refresh_content (frame_t *f)
{
	data_t 		*data 			= (data_t *) f->priv;	
	char 		*tmppath 		= frame_get_absolute_tmp_path (f, "selinux_plot.svg");
	char		*file_name		= g_strdup_printf ("selinux_%i.txt", f->display_period.type);
	char		*path 			= frame_get_absolute_reports_path (f, file_name, NULL);
	char		*path_out		= frame_get_absolute_tmp_path (f, "agg_alerts_machines");
	char		*command		= NULL;
	char 		*script		 	= frame_get_absolute_data_path (f, data->ploticus_script);
	char 		*reportsdir 		= frame_get_absolute_reports_path (f, NULL, NULL);

	struct stat file;
	stat(path, &file);
	if (stat(path, &file) == 0) {
		if(g_strcmp0(data->ploticus_script,"text")!=0 ) {
			if (machine_is_all_machines (f->display_machine) && g_strcmp0(data->ploticus_script,"agg_alerts_machines")==0) {  
			 //Selected graphic is alerts by machine and selected machine is all machines
				selinux_generate_machines_script(f);
				command = g_strdup_printf ("ploticus '%s' -svg -o '%s'",path_out, tmppath);
				system(command);
			}
			// Selected graphic is not alerts by machine or selected machine is not all machines
			else  { 
				command = g_strdup_printf ("ploticus '%s' -dir '%s' -svg -o '%s'", script, reportsdir, tmppath);
				system(command);
			}
		}
		
	}
	frame_request_redraw (f);
	g_free(file_name);
	g_free (tmppath);
	g_free(command);
	g_free (script);
	g_free(reportsdir);
	g_free(path);
	g_free(path_out);
	return 0;
}

int draw_area (frame_t *f, cairo_t *cr)
{
	char 				*path		= NULL;
	char 				*title		= NULL;
	data_t 				*data 		= (data_t *) f->priv;
	GError				*err		= NULL;
	RsvgHandle			*myhandle	= NULL;	
	
	if (g_strcmp0(data->ploticus_script,"text")==0) {
       		/* The user selected the text mode for one particular machine*/
		if (!machine_is_all_machines (f->display_machine))
			selinux_display_latest_text_alerts(f, cr);
		/* The user selected the text mode for all machines*/
		else
			selinux_display_text_statistics(f, cr);
	}
	else { /* Text logs not selected, display the SVG image generated by ploticus */
		cairo_set_source_rgb(cr, 1, 1, 1);
		cairo_paint(cr);		
		cairo_select_font_face (cr, "sans", CAIRO_FONT_SLANT_NORMAL, CAIRO_FONT_WEIGHT_BOLD);	
		cairo_set_font_size (cr, frame_get_height (f)*0.07);
		cairo_set_source_rgb (cr, 0.0, 0.0, 0.0);
		cairo_move_to(cr, frame_get_width (f)*0.30, frame_get_height (f)*0.35);
		cairo_show_text (cr, "Loading ...");
		
		path = frame_get_absolute_tmp_path (f, "selinux_plot.svg");
		myhandle = rsvg_handle_new_from_file (path, &err);
		g_free (path);
		if (err) { 
			g_clear_error (&err);
		}
		else {
			cairo_save (cr); 

			cairo_scale (cr, 0.6*frame_get_width (f)/FRAME_WIDTH_NORMAL, 0.6*frame_get_height(f)/FRAME_HEIGHT_NORMAL );
			//cairo_rotate (cr, M_PI);
			rsvg_handle_render_cairo (myhandle, cr);
			cairo_restore (cr);
			g_object_unref (myhandle);
	
			//Display the graphic title
			title = selinux_graphic_title (f); 
			cairo_set_font_size (cr, frame_get_height (f)*0.05);
			cairo_move_to (cr, frame_get_width (f)*0.1, frame_get_height (f)*0.05);		
			cairo_show_text (cr, title);
			g_free (title);
		}
	}
				
	return 0;
}

int button_press_handler (frame_t *f, GdkEventButton *event, cairo_t *cr)
{
	data_t 	*data		= 	(data_t *) f->priv;
	char 	*file_name 	= 	g_strdup_printf ("selinux_%i.txt", f->display_period.type);			
	char 	*path 		=	frame_get_absolute_reports_path (f, file_name, NULL);

	if (g_strcmp0(data->ploticus_script,"text")==0 && !(machine_is_all_machines (f->display_machine)) ) {	
		if (event->x > frame_get_width (f)*0.9 && event->y > frame_get_height (f)*0.9) { 
			/*scrolling down page by page*/
			if (data->line_number_offset > 0) {
				data->line_number_offset -= 17;
			}
		}
		else if (event->x > frame_get_width (f)*0.9 && event->y < frame_get_height (f)*0.1) {
			/*scrolling up page by page*/
			if (data->line_number_offset < selinux_count_alerts(path) - NUMBER_OF_LINES){
				data->line_number_offset += 17;
			}
		}
		else if (event->x > frame_get_width (f)*0.9 && event->y < frame_get_height (f)*0.87 && event->y > frame_get_height (f)*0.82) {
			/*scrolling down line by line*/
			if (data->line_number_offset > 0) {
				data->line_number_offset -= 1;
			}
		}
		else if (event->x > frame_get_width (f)*0.9 && event->y > frame_get_height (f)*0.13 && event->y < frame_get_height (f)*0.18) {
			/*scrolling up line by line*/			
			if (data->line_number_offset < selinux_count_alerts(path) - NUMBER_OF_LINES){
				data->line_number_offset += 1;
			}
		}
	}
	g_free(path);
	g_free(file_name);
	return 0;
}

int button_release_handler (frame_t *f, GdkEventButton *event, cairo_t *cr)
{
	data_t 		*data 			= (data_t *) f->priv;
	char 		*file_name 		= g_strdup_printf ("selinux_%i.txt", f->display_period.type);			
	char 		*path 			= frame_get_absolute_reports_path (f, file_name, NULL);
	char 		*script_name 		= NULL;

	if ( g_strcmp0(data->ploticus_script,"text") != 0 && g_strrstr(data->ploticus_script, "machines")==NULL) {
		if(g_strcmp0(data->graph_type, "pie") == 0) {	
			data_set_graph_type(data->graph_type);
			data->graph_type = strdup ("bar");
		}
		else {	
			data_set_graph_type(data->graph_type);
			data->graph_type = strdup ("pie");
		}
		script_name = selinux_ploticus_script_name (f);
		data_set_graph_type(data->ploticus_script);
		data->ploticus_script = strdup (script_name);
	}
	
	frame_request_content_refresh (f);
	frame_request_redraw (f);g_free(script_name);

	g_free(file_name);
	g_free(path);


	return 0;
}


int init_private (frame_t *f)
{
	f->priv = malloc (sizeof (data_t));
	data_t *data = (data_t *) f->priv;
	char * name = NULL;	

	data->graph_type = g_strdup ("pie");
	data->line_number_offset = 0;
	if(machine_is_all_machines (f->display_machine)) {
		data->ploticus_script = g_strdup ("agg_alerts_machines");
		selinux_generate_machines_script(f);
	}
	else { 	
		name = g_strdup_printf ("agg_machines_%i", f->display_period.type);
		data->ploticus_script = strdup (name);
		g_free (name);
	}	
	frame_request_redraw (f);	
	
	return 0;
}


int free_private (frame_t *f)
{
	data_t 		*data 		= (data_t *) f->priv;
	g_free (data->ploticus_script);
	g_free(data->graph_type);
	free (data);

	return 0;
}

int restore_private(frame_t *f, GKeyFile *file)
{
	data_t 	*data = (data_t *) f->priv;
	GError 	*err = NULL;

	data_set_graph_type(data->ploticus_script);

	data->ploticus_script = g_key_file_get_string (file, f->get_display_name (f), "Ploticus Script", &err);
	if (err) {
		fprintf (stderr, "Could not load the ploticus script name (%s)\n", err->message);
		g_clear_error (&err);
	}

	data_set_graph_type(data->graph_type);
			
	data->graph_type = g_key_file_get_string (file, f->get_display_name (f), "Graph type", &err);
	if (err) {
		fprintf (stderr, "Could not load the graphic type (%s)\n", err->message);
		g_clear_error (&err);
	}

	data->line_number_offset = g_key_file_get_integer (file, f->get_display_name (f), "Line number offset", &err);
	if (err) {
		fprintf (stderr, "Could not load the line number offset (%s)\n", err->message);
		g_clear_error (&err);
	}

	return 0;
}

int save_private(frame_t *f, GKeyFile *file)
{
	data_t 		*data 		= (data_t *) f->priv;

	g_key_file_set_string (file, f->get_display_name (f), "Ploticus Script" ,data->ploticus_script);
	g_key_file_set_string (file, f->get_display_name (f), "Graph type" ,data->graph_type );
	g_key_file_set_integer (file, f->get_display_name (f), "Line number offset" ,data->line_number_offset);

	return 0;
}


int display_machine_changed (frame_t *f)
{	
	data_t 		*data 		= (data_t *) f->priv;
	char 		*script_name 		= NULL;

	script_name = selinux_ploticus_script_name (f);
	data_set_graph_type(data->ploticus_script);
	data->ploticus_script = strdup (script_name);


	frame_request_redraw (f);
	frame_request_content_refresh (f);
	g_free(script_name);
	return 0;
}


int time_period_changed (frame_t *f)
{	
	data_t 		*data 		= (data_t *) f->priv;
	char 		*script_name 		= NULL;

	script_name = selinux_ploticus_script_name (f);
	data_set_graph_type(data->ploticus_script);
	data->ploticus_script = strdup (script_name);

	frame_request_redraw (f);
	frame_request_content_refresh (f);
	g_free(script_name);
	return 0;
}


int frame_size_changed (frame_t *f)
{
	frame_request_redraw (f);

	return 0;
}

