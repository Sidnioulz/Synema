/* Generated by GOB (v2.0.16)   (do not edit directly) */

/* End world hunger, donate to the World Food Programme, http://www.wfp.org */


/* Copyright 2009 (c) ENSI de Bourges
 * 		88 boulevard Lahitolle, 18020 Bourges Cedex, France
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Written by Steve Dodier <sidnioulz@gmail.com>
 *
 * This file is an auto-generated GObject used in private functions for
 * Synema frames.
 */

#define GOB_VERSION_MAJOR 2
#define GOB_VERSION_MINOR 0
#define GOB_VERSION_PATCHLEVEL 16

#define selfp (self->_priv)

#include <string.h> /* memset() */

#ifdef G_LIKELY
#define ___GOB_LIKELY(expr) G_LIKELY(expr)
#define ___GOB_UNLIKELY(expr) G_UNLIKELY(expr)
#else /* ! G_LIKELY */
#define ___GOB_LIKELY(expr) (expr)
#define ___GOB_UNLIKELY(expr) (expr)
#endif /* G_LIKELY */


#include "frame-common.h"
#include "frame-signals.h"
#include "gedit-spinner.h"

/* self casting macros */
#define SELF(x) FRAME_SIGNALS(x)
#define SELF_CONST(x) FRAME_SIGNALS_CONST(x)
#define IS_SELF(x) FRAME_IS_SIGNALS(x)
#define TYPE_SELF FRAME_TYPE_SIGNALS
#define SELF_CLASS(x) FRAME_SIGNALS_CLASS(x)

#define SELF_GET_CLASS(x) FRAME_SIGNALS_GET_CLASS(x)

/* self typedefs */
typedef Framesignals Self;
typedef FramesignalsClass SelfClass;

/* here are local prototypes */
static void frame_signals_init (Framesignals * o) G_GNUC_UNUSED;
static void frame_signals_class_init (FramesignalsClass * c) G_GNUC_UNUSED;
static void ___real_frame_signals_spinner_stop (Framesignals * self, gpointer data);
static void ___real_frame_signals_spinner_start (Framesignals * self, gpointer data);

/*
 * Signal connection wrapper macro shortcuts
 */
#define self_connect__spinner_stop(object,func,data)	frame_signals_connect__spinner_stop((object),(func),(data))
#define self_connect_after__spinner_stop(object,func,data)	frame_signals_connect_after__spinner_stop((object),(func),(data))
#define self_connect_data__spinner_stop(object,func,data,destroy_data,flags)	frame_signals_connect_data__spinner_stop((object),(func),(data),(destroy_data),(flags))
#define self_connect__spinner_start(object,func,data)	frame_signals_connect__spinner_start((object),(func),(data))
#define self_connect_after__spinner_start(object,func,data)	frame_signals_connect_after__spinner_start((object),(func),(data))
#define self_connect_data__spinner_start(object,func,data,destroy_data,flags)	frame_signals_connect_data__spinner_start((object),(func),(data),(destroy_data),(flags))

typedef void  (*___Sig1) (Framesignals *, gpointer , gpointer);

static void
___marshal_Sig1 (GClosure *closure,
	GValue *return_value G_GNUC_UNUSED,
	guint n_param_values,
	const GValue *param_values,
	gpointer invocation_hint G_GNUC_UNUSED,
	gpointer marshal_data)
{
	register ___Sig1 callback;
	register GCClosure *cc = (GCClosure*) closure;
	register gpointer data1, data2;

	g_return_if_fail (n_param_values == 2);

	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = g_value_peek_pointer (param_values + 0);
	} else {
		data1 = g_value_peek_pointer (param_values + 0);
		data2 = closure->data;
	}

	callback = (___Sig1) (marshal_data != NULL ? marshal_data : cc->callback);

	callback ((Framesignals *)data1,
		(gpointer ) g_value_get_pointer (param_values + 1),
		data2);
}


enum {
	SPINNER_STOP_SIGNAL,
	SPINNER_START_SIGNAL,
	LAST_SIGNAL
};

static guint object_signals[LAST_SIGNAL] = {0};

/* pointer to the class of our parent */
static GObjectClass *parent_class = NULL;

/* Short form macros */
#define self_spinner_stop frame_signals_spinner_stop
#define self_spinner_start frame_signals_spinner_start
#define self_new frame_signals_new
GType
frame_signals_get_type (void)
{
	static GType type = 0;

	if ___GOB_UNLIKELY(type == 0) {
		static const GTypeInfo info = {
			sizeof (FramesignalsClass),
			(GBaseInitFunc) NULL,
			(GBaseFinalizeFunc) NULL,
			(GClassInitFunc) frame_signals_class_init,
			(GClassFinalizeFunc) NULL,
			NULL /* class_data */,
			sizeof (Framesignals),
			0 /* n_preallocs */,
			(GInstanceInitFunc) frame_signals_init,
			NULL
		};

		type = g_type_register_static (G_TYPE_OBJECT, "Framesignals", &info, (GTypeFlags)0);
	}

	return type;
}

/* a macro for creating a new object of our type */
#define GET_NEW ((Framesignals *)g_object_new(frame_signals_get_type(), NULL))

/* a function for creating a new object of our type */
#include <stdarg.h>
static Framesignals * GET_NEW_VARG (const char *first, ...) G_GNUC_UNUSED;
static Framesignals *
GET_NEW_VARG (const char *first, ...)
{
	Framesignals *ret;
	va_list ap;
	va_start (ap, first);
	ret = (Framesignals *)g_object_new_valist (frame_signals_get_type (), first, ap);
	va_end (ap);
	return ret;
}

static void 
frame_signals_init (Framesignals * o G_GNUC_UNUSED)
{
#define __GOB_FUNCTION__ "Frame:signals::init"
}
#undef __GOB_FUNCTION__
static void 
frame_signals_class_init (FramesignalsClass * c G_GNUC_UNUSED)
{
#define __GOB_FUNCTION__ "Frame:signals::class_init"
	GObjectClass *g_object_class G_GNUC_UNUSED = (GObjectClass*) c;

	parent_class = g_type_class_ref (G_TYPE_OBJECT);

	object_signals[SPINNER_STOP_SIGNAL] =
		g_signal_new ("spinner_stop",
			G_TYPE_FROM_CLASS (g_object_class),
			(GSignalFlags)(G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION),
			G_STRUCT_OFFSET (FramesignalsClass, spinner_stop),
			NULL, NULL,
			___marshal_Sig1,
			G_TYPE_NONE, 1,
			G_TYPE_POINTER);
	if ___GOB_UNLIKELY(sizeof(gpointer ) != sizeof(gpointer ) || parent_class == NULL /* avoid warning */) {
		g_error("/home/steve/SYNEMA/data/frame-signals.gob line 32: Type mismatch of \"spinner_stop\" signal signature");
	}
	object_signals[SPINNER_START_SIGNAL] =
		g_signal_new ("spinner_start",
			G_TYPE_FROM_CLASS (g_object_class),
			(GSignalFlags)(G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION),
			G_STRUCT_OFFSET (FramesignalsClass, spinner_start),
			NULL, NULL,
			___marshal_Sig1,
			G_TYPE_NONE, 1,
			G_TYPE_POINTER);
	if ___GOB_UNLIKELY(sizeof(gpointer ) != sizeof(gpointer ) || parent_class == NULL /* avoid warning */) {
		g_error("/home/steve/SYNEMA/data/frame-signals.gob line 45: Type mismatch of \"spinner_start\" signal signature");
	}

	c->spinner_stop = ___real_frame_signals_spinner_stop;
	c->spinner_start = ___real_frame_signals_spinner_start;
}
#undef __GOB_FUNCTION__



void 
frame_signals_spinner_stop (Framesignals * self, gpointer data)
{
	GValue ___param_values[2];
	GValue ___return_val;

memset (&___return_val, 0, sizeof (___return_val));
memset (&___param_values, 0, sizeof (___param_values));

	g_return_if_fail (self != NULL);
	g_return_if_fail (FRAME_IS_SIGNALS (self));

	___param_values[0].g_type = 0;
	g_value_init (&___param_values[0], G_TYPE_FROM_INSTANCE (self));
	g_value_set_instance (&___param_values[0], (gpointer) self);

	___param_values[1].g_type = 0;
	g_value_init (&___param_values[1], G_TYPE_POINTER);
	g_value_set_pointer (&___param_values[1], (gpointer ) data);

	g_signal_emitv (___param_values,
		object_signals[SPINNER_STOP_SIGNAL],
		0 /* detail */,
		&___return_val);

	g_value_unset (&___param_values[0]);
	g_value_unset (&___param_values[1]);
}
static void 
___real_frame_signals_spinner_stop (Framesignals * self G_GNUC_UNUSED, gpointer data)
{
#define __GOB_FUNCTION__ "Frame:signals::spinner_stop"
{
	
        	frame_t *f = (frame_t *) data;
        	
        	if (f) {
        		if (f->computing_spinner) {
					gedit_spinner_stop (GEDIT_SPINNER (f->computing_spinner));
        		}
        	}
        }}
#undef __GOB_FUNCTION__

void 
frame_signals_spinner_start (Framesignals * self, gpointer data)
{
	GValue ___param_values[2];
	GValue ___return_val;

memset (&___return_val, 0, sizeof (___return_val));
memset (&___param_values, 0, sizeof (___param_values));

	g_return_if_fail (self != NULL);
	g_return_if_fail (FRAME_IS_SIGNALS (self));

	___param_values[0].g_type = 0;
	g_value_init (&___param_values[0], G_TYPE_FROM_INSTANCE (self));
	g_value_set_instance (&___param_values[0], (gpointer) self);

	___param_values[1].g_type = 0;
	g_value_init (&___param_values[1], G_TYPE_POINTER);
	g_value_set_pointer (&___param_values[1], (gpointer ) data);

	g_signal_emitv (___param_values,
		object_signals[SPINNER_START_SIGNAL],
		0 /* detail */,
		&___return_val);

	g_value_unset (&___param_values[0]);
	g_value_unset (&___param_values[1]);
}
static void 
___real_frame_signals_spinner_start (Framesignals * self G_GNUC_UNUSED, gpointer data)
{
#define __GOB_FUNCTION__ "Frame:signals::spinner_start"
{
	
        	frame_t *f = (frame_t *) data;
        	
        	if (f) {
        		if ((f->show_spinner) && (f->computing_spinner)) {
					gedit_spinner_start (GEDIT_SPINNER (f->computing_spinner));
        		}
        	}
        }}
#undef __GOB_FUNCTION__

GObject * 
frame_signals_new (void)
{
#define __GOB_FUNCTION__ "Frame:signals::new"
{
	
                return (GObject *)GET_NEW;
        }}
#undef __GOB_FUNCTION__
